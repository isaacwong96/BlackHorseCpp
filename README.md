# C++基础入门

# C++核心编程

## 1 内存分区模型

* 代码区：存放函数体的二进制代码，由操作系统进行管理
* 全局区：存放全局变量和静态变量以及常量
* 栈区：由编译器自动分配释放，存放函数的参数值，局部变量
* 堆区：由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收

### 1.1 程序运行前

在程序编译后，生成了exe可执行程序，**未执行该程序前**分为两个区域

* 代码区：
  * 存放CPU执行的机器指令
  * 代码区是共享的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可
  * 代码区是只读的，使其只读的原因是防止程序意外地修改了它的指令
* 全局区：
  * 全局变量和静态变量存放在此
  * 还包含了常量区，字符串常量和其他常量（const修饰的）也存放在此
  * **该区域的数据在程序结束后由操作系统释放**

---

* 不在全局区
  * 局部变量、const修饰的局部变量（局部常量）
* 全局区
  * 静态变量、static关键字
  * 常量
    * 字符串常量
    * const修饰的全局变量（全局常量）

### 1.2 程序运行后

* 栈区
  * 由编译器自动分配释放，存放函数的参数值，局部变量等
  * 注意：不要返回局部变量的地址，栈区开辟的数据由编译器自动释放

* 堆
  * 由程序员分配释放，若程序员不释放，程序结束时由操作系统回收
  * 在C++中主要利用new在堆区开辟内存


### 1.3 new操作符

* 返回的是指定类型的指针
* 用delete来释放
  * delete p;//释放单个变量
  * delete[] p;//释放数组

## 2 引用

### 2.1 引用的基本使用

* 作用：给变量起别名
* 语法：`数据类型 &别名 = 原名`

### 2.2 引用注意事项

* 引用必须初始化
  * `int &b;//错误的`
* 初始化后，不可以改变

### 2.3 引用做函数参数

* 作用：函数传参时，可以利用引用的支术让形参修饰实参
* 优点：可以简化指针修改实参
* 总结：通过引用参数产生的效果同按地址传递是一样的。引用的语法更清楚简单

### 2.4 引用做函数返回值

* 作用：引用是可以作为函数的返回值存在的
* 注意：不要返回局部变量引用
* 用法：函数调用作用左值
* 如果函数的返回值是引用，则这个函数调用可以作为左值

### 2.5 引用的本质

* 本质：引用的本质在C++内部实现是一个指针常量

  * 正因如此，初始化后就不能再改变

* ```C++
  void func(int& ref){
      ref = 100;
  }
  int main(){
      int a = 10;
      //自动转换为int * const ref = &a;指针常量：指针指向不可改变，也说明为什么引用不可更改
      int& ref = a;
      ref = 20;//内部发现ref是引用，自动帮我们转换： *ref = 20;
      
      cout<<"a:"<<a<<endl;
      cout<<"ref:"<<ref<<endl;
      
      func(a);
      return 0;
  }
  ```

* 结论：C++推荐使用引用技术，因为语法方便，引用本质是指针常量，但所有的指针操作编译器都帮我们做了

### 2.6 常量引用

* 作用：主要用来修饰形参，防止误操作

  * 在函数形参列表中，可以加const修修饰

* ```C++
  int main(){
      //常量引用
      //使用场景：用来修饰形参，防止误操作
      int a = 10;
      //error:引用必须引用一块合法的内存空间
      //int &ref = 10;
      //加上const之后，编译器将代码修改为 int tmp = 10;int &ref = tmp;
      const int &ref = 10;
      //error：加入const之后变为只读，不可以修改
      //ref = 20;
  }
  ```

* 

# C++ 提高编程

